<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Deformation Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #2a2a2a;
            color: #fff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #4CAF50;
        }
        .controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .controls label {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .controls select, .controls button, .controls input {
            padding: 8px 16px;
            margin-right: 10px;
            margin-bottom: 10px;
            background: #555;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls button:hover {
            background: #666;
        }
        .controls button.preview-btn {
            background: #4CAF50;
            font-weight: bold;
        }
        .controls button.preview-btn:hover {
            background: #45a049;
        }
        .upload-label {
            background: #2196F3;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .upload-label:hover {
            background: #1976D2;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
            background: #111;
            border: 2px solid #555;
            border-radius: 8px;
        }
        canvas {
            display: block;
        }
        .control-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: rgba(76, 175, 80, 0.8);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: move;
            transform: translate(-50%, -50%);
        }
        .control-point:hover {
            background: rgba(255, 235, 59, 0.9);
        }
        .control-point.selected {
            background: rgba(33, 150, 243, 0.9);
            border-color: #FFC107;
            border-width: 3px;
        }
        .selection-box {
            position: absolute;
            border: 2px dashed #2196F3;
            background: rgba(33, 150, 243, 0.1);
            pointer-events: none;
            display: none;
        }
        .instructions {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .instructions h3 {
            margin-top: 0;
            color: #4CAF50;
        }
        .instructions ol {
            line-height: 1.8;
        }
        .json-output {
            background: #000;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.3;
        }
        #meshCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ Mesh Deformation Editor</h1>

        <div class="controls">
            <div>
                <label for="frameSelect">Frame:</label>
                <select id="frameSelect">
                    <option value="1">Frame 1</option>
                    <option value="2">Frame 2</option>
                    <option value="3">Frame 3</option>
                    <option value="4">Frame 4</option>
                    <option value="5">Frame 5</option>
                    <option value="6">Frame 6</option>
                </select>

                <label for="gridSize">Grid Size:</label>
                <select id="gridSize">
                    <option value="5">5x5</option>
                    <option value="8">8x8</option>
                    <option value="10" selected>10x10</option>
                    <option value="12">12x12</option>
                    <option value="15">15x15</option>
                </select>

                <label>
                    <input type="checkbox" id="showGrid" checked> Show Reference Grid
                </label>
                <label>
                    <input type="checkbox" id="showMesh" checked> Show Mesh Lines
                </label>
            </div>

            <div>
                <label for="textureUpload" class="upload-label">ðŸ“· Upload Test Texture</label>
                <input type="file" id="textureUpload" accept="image/*" hidden>
                <button id="previewBtn" class="preview-btn" style="display: none;">ðŸ”„ Preview Deformation</button>
            </div>

            <div>
                <button id="resetBtn">Reset Deformation</button>
                <button id="copyBtn">Copy to All Frames</button>
                <button id="exportBtn">Export JSON</button>
                <button id="importBtn">Import JSON</button>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="gridCanvas" class="grid-overlay"></canvas>
            <canvas id="mainCanvas"></canvas>
            <canvas id="meshCanvas"></canvas>
            <div id="selectionBox" class="selection-box"></div>
        </div>

        <div class="instructions">
            <h3>Instructions</h3>
            <ol>
                <li><strong>Upload a test texture</strong> - Click "Upload Test Texture" to load an image you want to test with</li>
                <li><strong>Select a frame</strong> from the dropdown above</li>
                <li><strong>Drag the green control points</strong> to deform the mesh - imagine warping the texture to match the character's body contours</li>
                <li><strong>Click "Preview Deformation"</strong> to see how your texture looks with the current deformation</li>
                <li>Iterate: adjust points, preview, repeat until it looks good</li>
                <li><strong>Click "Export JSON"</strong> when done to get the deformation data</li>
                <li>Save the JSON output to <code>deformations.js</code> in your project</li>
            </ol>

            <h3>Tips:</h3>
            <ul>
                <li>Start with subtle deformations - less is more!</li>
                <li>Focus on making the texture follow the body's curves and depth</li>
                <li>The center area (where the texture is applied) needs the most attention</li>
                <li>Edge areas can remain mostly undeformed</li>
                <li><strong>Multi-select:</strong> Hold Shift and drag to select multiple control points, then drag them together</li>
                <li><strong>Mesh lines:</strong> Colored horizontal lines show rows (easier to see deformation), gray vertical lines show columns</li>
            </ul>

            <h3>JSON Output:</h3>
            <div class="json-output" id="jsonOutput">Click "Export JSON" to generate deformation data...</div>
        </div>
    </div>

    <script src="mesh-deform-simple.js"></script>
    <script>
        const SOURCE_SIZE = 480;
        const SOURCE_CROP = 24;  // Match the crop from app.js
        const CANVAS_SIZE = SOURCE_SIZE - (SOURCE_CROP * 2);  // 432px - display cropped area

        const FRAME_PATHS = [
            'masks/frame_1_base.png',
            'masks/frame_2_base.png',
            'masks/frame_3_base.png',
            'masks/frame_4_base.png',
            'masks/frame_5_base.png',
            'masks/frame_6_base.png',
        ];

        // State
        let currentFrame = 1;
        let gridResolution = 10;
        let frameDeformations = {};
        let controlPoints = [];
        let draggedPoint = null;
        let selectedPoints = [];
        let isShiftPressed = false;
        let isSelectingBox = false;
        let selectionStartX = 0;
        let selectionStartY = 0;
        let dragStartPositions = new Map(); // Store initial positions when dragging multiple points
        let baseImage = null;
        let testTexture = null;
        let deformer = null;

        // Initialize deformations for all frames
        for (let i = 1; i <= 6; i++) {
            frameDeformations[i] = [];
        }

        // DOM elements
        const mainCanvas = document.getElementById('mainCanvas');
        const gridCanvas = document.getElementById('gridCanvas');
        const meshCanvas = document.getElementById('meshCanvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const frameSelect = document.getElementById('frameSelect');
        const gridSizeSelect = document.getElementById('gridSize');
        const showGridCheckbox = document.getElementById('showGrid');
        const showMeshCheckbox = document.getElementById('showMesh');
        const jsonOutput = document.getElementById('jsonOutput');
        const textureUpload = document.getElementById('textureUpload');
        const previewBtn = document.getElementById('previewBtn');
        const selectionBox = document.getElementById('selectionBox');

        mainCanvas.width = mainCanvas.height = CANVAS_SIZE;
        gridCanvas.width = gridCanvas.height = CANVAS_SIZE;
        meshCanvas.width = meshCanvas.height = CANVAS_SIZE;

        const ctx = mainCanvas.getContext('2d');
        const gridCtx = gridCanvas.getContext('2d');
        const meshCtx = meshCanvas.getContext('2d');

        // Load current frame
        function loadFrame(frameNum) {
            const img = new Image();
            img.onload = () => {
                baseImage = img;
                redrawCanvas();
                createControlPoints();
                drawGrid();
            };
            img.src = FRAME_PATHS[frameNum - 1];
        }

        // Redraw canvas with current view (base frame or preview)
        function redrawCanvas() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            if (baseImage) {
                // Draw cropped portion (matching the 24px crop in app.js)
                ctx.drawImage(
                    baseImage,
                    SOURCE_CROP, SOURCE_CROP, CANVAS_SIZE, CANVAS_SIZE,  // Source: crop from edges
                    0, 0, CANVAS_SIZE, CANVAS_SIZE                       // Dest: fill canvas
                );
            }
        }

        // Handle texture upload
        textureUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    testTexture = img;
                    previewBtn.style.display = 'inline-block';
                    alert('Texture loaded! Click "Preview Deformation" to see it with your current mesh.');
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Helper function to center-crop texture to square
        function centerCropToSquare(image) {
            const size = Math.min(image.width, image.height);
            const offsetX = (image.width - size) / 2;
            const offsetY = (image.height - size) / 2;

            const canvas = document.createElement('canvas');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            const ctx = canvas.getContext('2d');

            // Draw the center square portion of the image
            ctx.drawImage(
                image,
                offsetX, offsetY, size, size,      // Source: center square
                0, 0, CANVAS_SIZE, CANVAS_SIZE     // Dest: fill canvas
            );

            return canvas;
        }

        // Preview deformation with test texture
        previewBtn.addEventListener('click', () => {
            if (!testTexture) {
                alert('Please upload a test texture first!');
                return;
            }

            if (!deformer) {
                try {
                    deformer = new MeshDeformer(CANVAS_SIZE, CANVAS_SIZE, gridResolution);
                } catch (error) {
                    alert('Failed to initialize deformer: ' + error.message);
                    return;
                }
            }

            // Update deformations first
            updateDeformation();

            const currentDeformations = frameDeformations[currentFrame];

            // Convert pixel-based deformations to normalized coordinates for the deformer
            const normalizedDeformations = currentDeformations.map(d => ({
                x: d.x,
                y: d.y,
                dx: d.dx / CANVAS_SIZE * 2,  // Convert to -1 to 1 range
                dy: d.dy / CANVAS_SIZE * 2
            }));

            try {
                // Center-crop texture to square before deformation
                const croppedTexture = centerCropToSquare(testTexture);

                // Apply deformation
                deformer.applyDeformation(normalizedDeformations);
                const deformedCanvas = deformer.render(croppedTexture);

                // Draw deformed texture
                ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.drawImage(deformedCanvas, 0, 0);

                // Overlay the base frame (character outline) with transparency
                if (baseImage) {
                    ctx.globalAlpha = 0.5;
                    // Draw cropped portion of base image
                    ctx.drawImage(
                        baseImage,
                        SOURCE_CROP, SOURCE_CROP, CANVAS_SIZE, CANVAS_SIZE,
                        0, 0, CANVAS_SIZE, CANVAS_SIZE
                    );
                    ctx.globalAlpha = 1.0;
                }

                console.log('Preview rendered with', normalizedDeformations.length, 'deformations');
            } catch (error) {
                alert('Preview failed: ' + error.message);
                console.error('Preview error:', error);
            }
        });

        // Create control points
        function createControlPoints() {
            // Remove existing points
            document.querySelectorAll('.control-point').forEach(el => el.remove());
            controlPoints = [];

            const res = gridResolution;
            const spacing = CANVAS_SIZE / res;

            for (let y = 0; y <= res; y++) {
                for (let x = 0; x <= res; x++) {
                    const px = x * spacing;
                    const py = y * spacing;

                    const point = document.createElement('div');
                    point.className = 'control-point';
                    point.style.left = px + 'px';
                    point.style.top = py + 'px';
                    point.dataset.gridX = x;
                    point.dataset.gridY = y;
                    point.dataset.baseX = px;
                    point.dataset.baseY = py;

                    // Apply saved deformation if exists
                    const saved = frameDeformations[currentFrame].find(
                        d => Math.round(d.x * res) === x && Math.round(d.y * res) === y
                    );
                    if (saved) {
                        point.style.left = (px + saved.dx) + 'px';
                        point.style.top = (py - saved.dy) + 'px'; // Negative because we store inverted Y
                    }

                    canvasContainer.appendChild(point);
                    controlPoints.push(point);

                    // Add drag handlers
                    point.addEventListener('mousedown', startDrag);
                }
            }

            // Draw mesh lines after creating points
            drawMesh();
        }

        // Draw reference grid overlay
        function drawGrid() {
            gridCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            if (!showGridCheckbox.checked) {
                gridCanvas.style.display = 'none';
                return;
            }

            gridCanvas.style.display = 'block';
            gridCtx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
            gridCtx.lineWidth = 1;

            const res = gridResolution;
            const spacing = CANVAS_SIZE / res;

            // Draw vertical lines
            for (let x = 0; x <= res; x++) {
                const px = x * spacing;
                gridCtx.beginPath();
                gridCtx.moveTo(px, 0);
                gridCtx.lineTo(px, CANVAS_SIZE);
                gridCtx.stroke();
            }

            // Draw horizontal lines
            for (let y = 0; y <= res; y++) {
                const py = y * spacing;
                gridCtx.beginPath();
                gridCtx.moveTo(0, py);
                gridCtx.lineTo(CANVAS_SIZE, py);
                gridCtx.stroke();
            }
        }

        // Get color for a row (hue-based gradient)
        function getRowColor(rowIndex, totalRows) {
            // Create a rainbow gradient across rows
            const hue = (rowIndex / totalRows) * 300; // 0-300 degrees (avoid red overlap)
            return `hsla(${hue}, 70%, 60%, 0.8)`;
        }

        // Draw mesh lines connecting control points
        function drawMesh() {
            meshCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            if (!showMeshCheckbox.checked) {
                meshCanvas.style.display = 'none';
                return;
            }

            meshCanvas.style.display = 'block';
            const res = gridResolution;

            // Draw horizontal lines (rows) with different colors
            for (let y = 0; y <= res; y++) {
                meshCtx.strokeStyle = getRowColor(y, res);
                meshCtx.lineWidth = 2;
                meshCtx.beginPath();

                for (let x = 0; x <= res; x++) {
                    const index = y * (res + 1) + x;
                    const point = controlPoints[index];
                    if (!point) continue;

                    const px = parseFloat(point.style.left);
                    const py = parseFloat(point.style.top);

                    if (x === 0) {
                        meshCtx.moveTo(px, py);
                    } else {
                        meshCtx.lineTo(px, py);
                    }
                }
                meshCtx.stroke();
            }

            // Draw vertical lines (columns) with neutral color
            meshCtx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
            meshCtx.lineWidth = 1;

            for (let x = 0; x <= res; x++) {
                meshCtx.beginPath();

                for (let y = 0; y <= res; y++) {
                    const index = y * (res + 1) + x;
                    const point = controlPoints[index];
                    if (!point) continue;

                    const px = parseFloat(point.style.left);
                    const py = parseFloat(point.style.top);

                    if (y === 0) {
                        meshCtx.moveTo(px, py);
                    } else {
                        meshCtx.lineTo(px, py);
                    }
                }
                meshCtx.stroke();
            }
        }

        // Keyboard handlers for shift key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') {
                isShiftPressed = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
                isShiftPressed = false;
            }
        });

        // Drag handlers
        function startDrag(e) {
            e.preventDefault();
            e.stopPropagation();

            if (isShiftPressed) {
                // Toggle selection
                if (selectedPoints.includes(e.target)) {
                    selectedPoints = selectedPoints.filter(p => p !== e.target);
                    e.target.classList.remove('selected');
                } else {
                    selectedPoints.push(e.target);
                    e.target.classList.add('selected');
                }
            } else {
                // Start dragging
                if (selectedPoints.includes(e.target)) {
                    // Dragging a selected point - move all selected points
                    draggedPoint = e.target;
                    dragStartPositions.clear();
                    selectedPoints.forEach(point => {
                        dragStartPositions.set(point, {
                            x: parseFloat(point.style.left),
                            y: parseFloat(point.style.top)
                        });
                    });
                } else {
                    // Clear selection and drag single point
                    selectedPoints.forEach(p => p.classList.remove('selected'));
                    selectedPoints = [];
                    draggedPoint = e.target;
                }
            }
        }

        // Canvas mouse handlers for box selection
        canvasContainer.addEventListener('mousedown', (e) => {
            // Only start box selection if clicking on the canvas itself (not a control point)
            if (isShiftPressed && (e.target === canvasContainer || e.target === mainCanvas || e.target === gridCanvas)) {
                isSelectingBox = true;
                const rect = canvasContainer.getBoundingClientRect();
                selectionStartX = e.clientX - rect.left;
                selectionStartY = e.clientY - rect.top;
                selectionBox.style.display = 'block';
                selectionBox.style.left = selectionStartX + 'px';
                selectionBox.style.top = selectionStartY + 'px';
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            const rect = canvasContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Handle box selection
            if (isSelectingBox) {
                const width = Math.abs(x - selectionStartX);
                const height = Math.abs(y - selectionStartY);
                const left = Math.min(x, selectionStartX);
                const top = Math.min(y, selectionStartY);

                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
                return;
            }

            // Handle point dragging
            if (!draggedPoint) return;

            // Constrain to canvas
            const clampedX = Math.max(0, Math.min(CANVAS_SIZE, x));
            const clampedY = Math.max(0, Math.min(CANVAS_SIZE, y));

            if (selectedPoints.length > 1 && selectedPoints.includes(draggedPoint)) {
                // Move all selected points together
                const draggedStartPos = dragStartPositions.get(draggedPoint);
                if (!draggedStartPos) {
                    console.warn('Missing start position for dragged point');
                    return;
                }

                const deltaX = clampedX - draggedStartPos.x;
                const deltaY = clampedY - draggedStartPos.y;

                selectedPoints.forEach(point => {
                    const pointStartPos = dragStartPositions.get(point);
                    if (pointStartPos) {
                        const newX = Math.max(0, Math.min(CANVAS_SIZE, pointStartPos.x + deltaX));
                        const newY = Math.max(0, Math.min(CANVAS_SIZE, pointStartPos.y + deltaY));
                        point.style.left = newX + 'px';
                        point.style.top = newY + 'px';
                    }
                });
            } else if (draggedPoint) {
                // Move single point
                draggedPoint.style.left = clampedX + 'px';
                draggedPoint.style.top = clampedY + 'px';
            }

            updateDeformation();
            drawMesh(); // Redraw mesh lines as points move
        });

        document.addEventListener('mouseup', (e) => {
            if (isSelectingBox) {
                // Select all points within the box
                const rect = canvasContainer.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                const left = Math.min(selectionStartX, currentX);
                const right = Math.max(selectionStartX, currentX);
                const top = Math.min(selectionStartY, currentY);
                const bottom = Math.max(selectionStartY, currentY);

                controlPoints.forEach(point => {
                    const px = parseFloat(point.style.left);
                    const py = parseFloat(point.style.top);

                    if (px >= left && px <= right && py >= top && py <= bottom) {
                        if (!selectedPoints.includes(point)) {
                            selectedPoints.push(point);
                            point.classList.add('selected');
                        }
                    }
                });

                selectionBox.style.display = 'none';
                isSelectingBox = false;
            }

            draggedPoint = null;
            dragStartPositions.clear();
        });

        // Update deformation data
        function updateDeformation() {
            const deformations = [];
            const res = gridResolution;

            controlPoints.forEach(point => {
                const gridX = parseInt(point.dataset.gridX);
                const gridY = parseInt(point.dataset.gridY);
                const baseX = parseFloat(point.dataset.baseX);
                const baseY = parseFloat(point.dataset.baseY);

                const currentX = parseFloat(point.style.left);
                const currentY = parseFloat(point.style.top);

                const dx = currentX - baseX; // Pixel displacement
                const dy = -(currentY - baseY); // Negative because canvas Y is inverted (down = positive)

                // Only store if there's actual deformation
                if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                    deformations.push({
                        x: gridX / res,  // Normalized grid position
                        y: gridY / res,
                        dx,  // Pixel displacement
                        dy
                    });
                }
            });

            frameDeformations[currentFrame] = deformations;
        }

        // Event listeners
        frameSelect.addEventListener('change', (e) => {
            currentFrame = parseInt(e.target.value);
            // Clear selection when changing frames
            selectedPoints.forEach(p => p.classList.remove('selected'));
            selectedPoints = [];
            loadFrame(currentFrame);
        });

        gridSizeSelect.addEventListener('change', (e) => {
            gridResolution = parseInt(e.target.value);
            // Clear selection when changing grid size
            selectedPoints.forEach(p => p.classList.remove('selected'));
            selectedPoints = [];
            createControlPoints();
            drawGrid();
        });

        showGridCheckbox.addEventListener('change', drawGrid);
        showMeshCheckbox.addEventListener('change', drawMesh);

        document.getElementById('resetBtn').addEventListener('click', () => {
            frameDeformations[currentFrame] = [];
            selectedPoints.forEach(p => p.classList.remove('selected'));
            selectedPoints = [];
            createControlPoints();
            redrawCanvas();
            drawMesh();
        });

        document.getElementById('copyBtn').addEventListener('click', () => {
            const current = frameDeformations[currentFrame];
            for (let i = 1; i <= 6; i++) {
                frameDeformations[i] = JSON.parse(JSON.stringify(current));
            }
            alert('Deformation copied to all frames!');
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            updateDeformation(); // Make sure current frame is saved

            const output = `// ========== MESH DEFORMATION DATA ==========
// This file defines how textures are deformed to appear 3D
//
// Generated by mesh-editor.html
// Grid resolution: ${gridResolution}x${gridResolution}
// ===========================================

/**
 * Get deformation data for a specific frame
 * @param {number} frameIndex - Frame index (0-5)
 * @returns {Array} Array of deformation points {x, y, dx, dy}
 */
function getFrameDeformation(frameIndex) {
    const deformations = ${JSON.stringify(frameDeformations, null, 4)};
    return deformations[frameIndex + 1] || [];
}
`;
            jsonOutput.textContent = output;

            // Also copy to clipboard
            navigator.clipboard.writeText(output).then(() => {
                alert('Deformation data copied to clipboard!\n\nPaste this into deformations.js to use in your app.');
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Data is shown below - copy it manually to deformations.js');
            });
        });

        document.getElementById('importBtn').addEventListener('click', () => {
            const json = prompt('Paste deformation JSON:');
            if (json) {
                try {
                    const data = JSON.parse(json);
                    frameDeformations = data;
                    loadFrame(currentFrame);
                    alert('Deformation data imported!');
                } catch (e) {
                    alert('Invalid JSON: ' + e.message);
                }
            }
        });

        // Initialize
        loadFrame(1);
    </script>
</body>
</html>
